// This code was automatically generated by GDExtension C# Bindgen
using System;
using System.Diagnostics.CodeAnalysis;
using Godot;

namespace GDExtensionBindgen;

#nullable disable

public class PTY
{
	// Engine object used for calling engine methods
	protected Node _object;

	public PTY() : this(NativeName)
	{
	}
	protected PTY(StringName @class) : this(ClassDB.Instantiate(@class))
	{
	}
	protected PTY(Variant variant) : this((Node) variant)
	{
	}
	protected PTY([NotNull] Node @object)
	{
		_object = @object;
	}

	public static implicit operator Node(PTY self) => self?._object;
	public static implicit operator Variant(PTY self) => self?._object;
	public static explicit operator PTY(Variant variant) => variant.AsGodotObject() != null ? new(variant) : null;

	public class PropertyName : Node.PropertyName
	{
		public static readonly StringName Cols = "cols";
		public static readonly StringName Rows = "rows";
		public static readonly StringName Env = "env";
		public static readonly StringName UseOsEnv = "use_os_env";
		public static readonly StringName UseThreads = "use_threads";
		public static readonly StringName TerminalPath = "terminal_path";
	}

	public class MethodName : Node.MethodName
	{
		public static readonly StringName SetCols = "set_cols";
		public static readonly StringName GetCols = "get_cols";
		public static readonly StringName SetRows = "set_rows";
		public static readonly StringName GetRows = "get_rows";
		public static readonly StringName GetEnv = "get_env";
		public static readonly StringName SetEnv = "set_env";
		public static readonly StringName GetUseOsEnv = "get_use_os_env";
		public static readonly StringName SetUseOsEnv = "set_use_os_env";
		public static readonly StringName SetUseThreads = "set_use_threads";
		public static readonly StringName IsUsingThreads = "is_using_threads";
		public static readonly StringName SetTerminalPath = "set_terminal_path";
		public static readonly StringName GetTerminalPath = "get_terminal_path";
		public static readonly StringName GetPtsName = "get_pts_name";
		public static readonly StringName Fork = "fork";
		public static readonly StringName Open = "open";
		public static readonly StringName Write = "write";
		public static readonly StringName Resize = "resize";
		public static readonly StringName Resizev = "resizev";
		public static readonly StringName Kill = "kill";
	}

	public class SignalName : Node.SignalName
	{
		public static readonly StringName DataReceived = "data_received";
		public static readonly StringName Exited = "exited";
	}

	private static readonly StringName NativeName = "PTY";

	#region Enums

	public enum IPCSignal : long
	{
		Hup = 1L,
		Int = 2L,
		Quit = 3L,
		Ill = 4L,
		Trap = 5L,
		Abrt = 6L,
		Fpe = 8L,
		Kill = 9L,
		Segv = 11L,
		Pipe = 13L,
		Alrm = 14L,
		Term = 15L,
	}

	#endregion

	#region Properties

	public int Cols
	{
		get => (int)_object.Get(PropertyName.Cols);
		set => _object.Set(PropertyName.Cols, value);
	}

	public int Rows
	{
		get => (int)_object.Get(PropertyName.Rows);
		set => _object.Set(PropertyName.Rows, value);
	}

	public Godot.Collections.Dictionary Env
	{
		get => (Godot.Collections.Dictionary)_object.Get(PropertyName.Env);
		set => _object.Set(PropertyName.Env, value);
	}

	public bool UseOsEnv
	{
		get => (bool)_object.Get(PropertyName.UseOsEnv);
		set => _object.Set(PropertyName.UseOsEnv, value);
	}

	public bool UseThreads
	{
		get => (bool)_object.Get(PropertyName.UseThreads);
		set => _object.Set(PropertyName.UseThreads, value);
	}

	public Godot.NodePath TerminalPath
	{
		get => (Godot.NodePath)_object.Get(PropertyName.TerminalPath);
		set => _object.Set(PropertyName.TerminalPath, value);
	}

	#endregion

	#region Inherited Properties

	public Godot.StringName Name
	{
		get => _object.Name;
		set => _object.Name = value;
	}

	public bool UniqueNameInOwner
	{
		get => _object.UniqueNameInOwner;
		set => _object.UniqueNameInOwner = value;
	}

	public string SceneFilePath
	{
		get => _object.SceneFilePath;
		set => _object.SceneFilePath = value;
	}

	public Node Owner
	{
		get => _object.Owner;
		set => _object.Owner = value;
	}

	public MultiplayerApi Multiplayer
	{
		get => _object.Multiplayer;
	}

	public Node.ProcessModeEnum ProcessMode
	{
		get => _object.ProcessMode;
		set => _object.ProcessMode = value;
	}

	public int ProcessPriority
	{
		get => _object.ProcessPriority;
		set => _object.ProcessPriority = value;
	}

	public int ProcessPhysicsPriority
	{
		get => _object.ProcessPhysicsPriority;
		set => _object.ProcessPhysicsPriority = value;
	}

	public Node.ProcessThreadGroupEnum ProcessThreadGroup
	{
		get => _object.ProcessThreadGroup;
		set => _object.ProcessThreadGroup = value;
	}

	public int ProcessThreadGroupOrder
	{
		get => _object.ProcessThreadGroupOrder;
		set => _object.ProcessThreadGroupOrder = value;
	}

	public Node.ProcessThreadMessagesEnum ProcessThreadMessages
	{
		get => _object.ProcessThreadMessages;
		set => _object.ProcessThreadMessages = value;
	}

	public Node.PhysicsInterpolationModeEnum PhysicsInterpolationMode
	{
		get => _object.PhysicsInterpolationMode;
		set => _object.PhysicsInterpolationMode = value;
	}

	public Node.AutoTranslateModeEnum AutoTranslateMode
	{
		get => _object.AutoTranslateMode;
		set => _object.AutoTranslateMode = value;
	}

	public string EditorDescription
	{
		get => _object.EditorDescription;
		set => _object.EditorDescription = value;
	}

	#endregion

	#region Methods

	public void SetCols(int @num_cols)
	{
		_object.Call(MethodName.SetCols, @num_cols);
	}

	public int GetCols()
	{
		return (int)_object.Call(MethodName.GetCols);
	}

	public void SetRows(int @num_rows)
	{
		_object.Call(MethodName.SetRows, @num_rows);
	}

	public int GetRows()
	{
		return (int)_object.Call(MethodName.GetRows);
	}

	public Godot.Collections.Dictionary GetEnv()
	{
		return (Godot.Collections.Dictionary)_object.Call(MethodName.GetEnv);
	}

	public void SetEnv(Godot.Collections.Dictionary @env)
	{
		_object.Call(MethodName.SetEnv, @env);
	}

	public bool GetUseOsEnv()
	{
		return (bool)_object.Call(MethodName.GetUseOsEnv);
	}

	public void SetUseOsEnv(bool @use_os_env)
	{
		_object.Call(MethodName.SetUseOsEnv, @use_os_env);
	}

	public void SetUseThreads(bool @enabled)
	{
		_object.Call(MethodName.SetUseThreads, @enabled);
	}

	public bool IsUsingThreads()
	{
		return (bool)_object.Call(MethodName.IsUsingThreads);
	}

	public void SetTerminalPath(Godot.NodePath @path)
	{
		_object.Call(MethodName.SetTerminalPath, @path);
	}

	public Godot.NodePath GetTerminalPath()
	{
		return (Godot.NodePath)_object.Call(MethodName.GetTerminalPath);
	}

	public string GetPtsName()
	{
		return (string)_object.Call(MethodName.GetPtsName);
	}

	public Godot.Error Fork(string @file = "", string[] @args = null!, string @cwd = ".", int @cols = 80, int @rows = 24)
	{
		args ??= [];
		return (Godot.Error)(int)_object.Call(MethodName.Fork, @file, @args, @cwd, @cols, @rows);
	}

	public Godot.Error Open(int @cols = 80, int @rows = 24)
	{
		return (Godot.Error)(int)_object.Call(MethodName.Open, @cols, @rows);
	}

	public void Write(Variant @data)
	{
		_object.Call(MethodName.Write, @data);
	}

	public void Resize(int @cols, int @rows)
	{
		_object.Call(MethodName.Resize, @cols, @rows);
	}

	public void Resizev(Godot.Vector2I @size)
	{
		_object.Call(MethodName.Resizev, @size);
	}

	public void Kill(int @signal)
	{
		_object.Call(MethodName.Kill, @signal);
	}

	#endregion

	#region Inherited Methods

	public static void PrintOrphanNodes()
	{
		Node.PrintOrphanNodes();
	}

	public void AddSibling(Node @sibling, bool @force_readable_name = false)
	{
		_object.AddSibling(@sibling, @force_readable_name);
	}

	public void SetName(string @name)
	{
		_object.SetName(@name);
	}

	public Godot.StringName GetName()
	{
		return _object.GetName();
	}

	public void AddChild(Node @node, bool @force_readable_name = false, Node.InternalMode @internal = (Node.InternalMode)0)
	{
		_object.AddChild(@node, @force_readable_name, @internal);
	}

	public void RemoveChild(Node @node)
	{
		_object.RemoveChild(@node);
	}

	public void Reparent(Node @new_parent, bool @keep_global_transform = true)
	{
		_object.Reparent(@new_parent, @keep_global_transform);
	}

	public int GetChildCount(bool @include_internal = false)
	{
		return _object.GetChildCount(@include_internal);
	}

	public Godot.Collections.Array<Godot.Node> GetChildren(bool @include_internal = false)
	{
		return _object.GetChildren(@include_internal);
	}

	public Node GetChild(int @idx, bool @include_internal = false)
	{
		return _object.GetChild(@idx, @include_internal);
	}

	public bool HasNode(Godot.NodePath @path)
	{
		return _object.HasNode(@path);
	}

	public Node GetNode(Godot.NodePath @path)
	{
		return _object.GetNode(@path);
	}

	public Node GetNodeOrNull(Godot.NodePath @path)
	{
		return _object.GetNodeOrNull(@path);
	}

	public Node GetParent()
	{
		return _object.GetParent();
	}

	public Node FindChild(string @pattern, bool @recursive = true, bool @owned = true)
	{
		return _object.FindChild(@pattern, @recursive, @owned);
	}

	public Godot.Collections.Array<Godot.Node> FindChildren(string @pattern, string @type = "", bool @recursive = true, bool @owned = true)
	{
		return _object.FindChildren(@pattern, @type, @recursive, @owned);
	}

	public Node FindParent(string @pattern)
	{
		return _object.FindParent(@pattern);
	}

	public bool HasNodeAndResource(Godot.NodePath @path)
	{
		return _object.HasNodeAndResource(@path);
	}

	public Godot.Collections.Array GetNodeAndResource(Godot.NodePath @path)
	{
		return _object.GetNodeAndResource(@path);
	}

	public bool IsInsideTree()
	{
		return _object.IsInsideTree();
	}

	public bool IsPartOfEditedScene()
	{
		return _object.IsPartOfEditedScene();
	}

	public bool IsAncestorOf(Node @node)
	{
		return _object.IsAncestorOf(@node);
	}

	public bool IsGreaterThan(Node @node)
	{
		return _object.IsGreaterThan(@node);
	}

	public Godot.NodePath GetPath()
	{
		return _object.GetPath();
	}

	public Godot.NodePath GetPathTo(Node @node, bool @use_unique_path = false)
	{
		return _object.GetPathTo(@node, @use_unique_path);
	}

	public void AddToGroup(Godot.StringName @group, bool @persistent = false)
	{
		_object.AddToGroup(@group, @persistent);
	}

	public void RemoveFromGroup(Godot.StringName @group)
	{
		_object.RemoveFromGroup(@group);
	}

	public bool IsInGroup(Godot.StringName @group)
	{
		return _object.IsInGroup(@group);
	}

	public void MoveChild(Node @child_node, int @to_index)
	{
		_object.MoveChild(@child_node, @to_index);
	}

	public Godot.Collections.Array<StringName> GetGroups()
	{
		return _object.GetGroups();
	}

	public void SetOwner(Node @owner)
	{
		_object.SetOwner(@owner);
	}

	public Node GetOwner()
	{
		return _object.GetOwner();
	}

	public int GetIndex(bool @include_internal = false)
	{
		return _object.GetIndex(@include_internal);
	}

	public void PrintTree()
	{
		_object.PrintTree();
	}

	public void PrintTreePretty()
	{
		_object.PrintTreePretty();
	}

	public string GetTreeString()
	{
		return _object.GetTreeString();
	}

	public string GetTreeStringPretty()
	{
		return _object.GetTreeStringPretty();
	}

	public void SetSceneFilePath(string @scene_file_path)
	{
		_object.SetSceneFilePath(@scene_file_path);
	}

	public string GetSceneFilePath()
	{
		return _object.GetSceneFilePath();
	}

	public void PropagateNotification(int @what)
	{
		_object.PropagateNotification(@what);
	}

	public void PropagateCall(Godot.StringName @method, Godot.Collections.Array @args = null, bool @parent_first = false)
	{
		@args ??= new();
		_object.PropagateCall(@method, @args, @parent_first);
	}

	public void SetPhysicsProcess(bool @enable)
	{
		_object.SetPhysicsProcess(@enable);
	}

	public float GetPhysicsProcessDeltaTime()
	{
		return (float)_object.GetPhysicsProcessDeltaTime();
	}

	public bool IsPhysicsProcessing()
	{
		return _object.IsPhysicsProcessing();
	}

	public float GetProcessDeltaTime()
	{
		return (float)_object.GetProcessDeltaTime();
	}

	public void SetProcess(bool @enable)
	{
		_object.SetProcess(@enable);
	}

	public void SetProcessPriority(int @priority)
	{
		_object.SetProcessPriority(@priority);
	}

	public int GetProcessPriority()
	{
		return _object.GetProcessPriority();
	}

	public void SetPhysicsProcessPriority(int @priority)
	{
		_object.SetPhysicsProcessPriority(@priority);
	}

	public int GetPhysicsProcessPriority()
	{
		return _object.GetPhysicsProcessPriority();
	}

	public bool IsProcessing()
	{
		return _object.IsProcessing();
	}

	public void SetProcessInput(bool @enable)
	{
		_object.SetProcessInput(@enable);
	}

	public bool IsProcessingInput()
	{
		return _object.IsProcessingInput();
	}

	public void SetProcessShortcutInput(bool @enable)
	{
		_object.SetProcessShortcutInput(@enable);
	}

	public bool IsProcessingShortcutInput()
	{
		return _object.IsProcessingShortcutInput();
	}

	public void SetProcessUnhandledInput(bool @enable)
	{
		_object.SetProcessUnhandledInput(@enable);
	}

	public bool IsProcessingUnhandledInput()
	{
		return _object.IsProcessingUnhandledInput();
	}

	public void SetProcessUnhandledKeyInput(bool @enable)
	{
		_object.SetProcessUnhandledKeyInput(@enable);
	}

	public bool IsProcessingUnhandledKeyInput()
	{
		return _object.IsProcessingUnhandledKeyInput();
	}

	public void SetProcessMode(Node.ProcessModeEnum @mode)
	{
		_object.SetProcessMode(@mode);
	}

	public Node.ProcessModeEnum GetProcessMode()
	{
		return _object.GetProcessMode();
	}

	public bool CanProcess()
	{
		return _object.CanProcess();
	}

	public void SetProcessThreadGroup(Node.ProcessThreadGroupEnum @mode)
	{
		_object.SetProcessThreadGroup(@mode);
	}

	public Node.ProcessThreadGroupEnum GetProcessThreadGroup()
	{
		return _object.GetProcessThreadGroup();
	}

	public void SetProcessThreadMessages(Node.ProcessThreadMessagesEnum @flags)
	{
		_object.SetProcessThreadMessages(@flags);
	}

	public Node.ProcessThreadMessagesEnum GetProcessThreadMessages()
	{
		return _object.GetProcessThreadMessages();
	}

	public void SetProcessThreadGroupOrder(int @order)
	{
		_object.SetProcessThreadGroupOrder(@order);
	}

	public int GetProcessThreadGroupOrder()
	{
		return _object.GetProcessThreadGroupOrder();
	}

	public void SetDisplayFolded(bool @fold)
	{
		_object.SetDisplayFolded(@fold);
	}

	public bool IsDisplayedFolded()
	{
		return _object.IsDisplayedFolded();
	}

	public void SetProcessInternal(bool @enable)
	{
		_object.SetProcessInternal(@enable);
	}

	public bool IsProcessingInternal()
	{
		return _object.IsProcessingInternal();
	}

	public void SetPhysicsProcessInternal(bool @enable)
	{
		_object.SetPhysicsProcessInternal(@enable);
	}

	public bool IsPhysicsProcessingInternal()
	{
		return _object.IsPhysicsProcessingInternal();
	}

	public void SetPhysicsInterpolationMode(Node.PhysicsInterpolationModeEnum @mode)
	{
		_object.SetPhysicsInterpolationMode(@mode);
	}

	public Node.PhysicsInterpolationModeEnum GetPhysicsInterpolationMode()
	{
		return _object.GetPhysicsInterpolationMode();
	}

	public bool IsPhysicsInterpolated()
	{
		return _object.IsPhysicsInterpolated();
	}

	public bool IsPhysicsInterpolatedAndEnabled()
	{
		return _object.IsPhysicsInterpolatedAndEnabled();
	}

	public void ResetPhysicsInterpolation()
	{
		_object.ResetPhysicsInterpolation();
	}

	public void SetAutoTranslateMode(Node.AutoTranslateModeEnum @mode)
	{
		_object.SetAutoTranslateMode(@mode);
	}

	public Node.AutoTranslateModeEnum GetAutoTranslateMode()
	{
		return _object.GetAutoTranslateMode();
	}

	public void SetTranslationDomainInherited()
	{
		_object.SetTranslationDomainInherited();
	}

	public Window GetWindow()
	{
		return _object.GetWindow();
	}

	public Window GetLastExclusiveWindow()
	{
		return _object.GetLastExclusiveWindow();
	}

	public SceneTree GetTree()
	{
		return _object.GetTree();
	}

	public Tween CreateTween()
	{
		return _object.CreateTween();
	}

	public Node Duplicate(int @flags = 15)
	{
		return _object.Duplicate(@flags);
	}

	public void ReplaceBy(Node @node, bool @keep_groups = false)
	{
		_object.ReplaceBy(@node, @keep_groups);
	}

	public void SetSceneInstanceLoadPlaceholder(bool @load_placeholder)
	{
		_object.SetSceneInstanceLoadPlaceholder(@load_placeholder);
	}

	public bool GetSceneInstanceLoadPlaceholder()
	{
		return _object.GetSceneInstanceLoadPlaceholder();
	}

	public void SetEditableInstance(Node @node, bool @is_editable)
	{
		_object.SetEditableInstance(@node, @is_editable);
	}

	public bool IsEditableInstance(Node @node)
	{
		return _object.IsEditableInstance(@node);
	}

	public Viewport GetViewport()
	{
		return _object.GetViewport();
	}

	public void QueueFree()
	{
		_object.QueueFree();
	}

	public void RequestReady()
	{
		_object.RequestReady();
	}

	public bool IsNodeReady()
	{
		return _object.IsNodeReady();
	}

	public void SetMultiplayerAuthority(int @id, bool @recursive = true)
	{
		_object.SetMultiplayerAuthority(@id, @recursive);
	}

	public int GetMultiplayerAuthority()
	{
		return _object.GetMultiplayerAuthority();
	}

	public bool IsMultiplayerAuthority()
	{
		return _object.IsMultiplayerAuthority();
	}

	public MultiplayerApi GetMultiplayer()
	{
		return _object.GetMultiplayer();
	}

	public void RpcConfig(Godot.StringName @method, Variant @config)
	{
		_object.RpcConfig(@method, @config);
	}

	public Variant GetRpcConfig()
	{
		return _object.GetRpcConfig();
	}

	public void SetEditorDescription(string @editor_description)
	{
		_object.SetEditorDescription(@editor_description);
	}

	public string GetEditorDescription()
	{
		return _object.GetEditorDescription();
	}

	public void SetUniqueNameInOwner(bool @enable)
	{
		_object.SetUniqueNameInOwner(@enable);
	}

	public bool IsUniqueNameInOwner()
	{
		return _object.IsUniqueNameInOwner();
	}

	public string Atr(string @message, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.Atr(@message, @context);
	}

	public string AtrN(string @message, Godot.StringName @plural_message, int @n, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.AtrN(@message, @plural_message, @n, @context);
	}

	public Godot.Error Rpc(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.Rpc(@method, varargs);
	}

	public Godot.Error RpcId(int @peer_id, Godot.StringName @method, params Variant[] varargs)
	{
		return _object.RpcId(@peer_id, @method, varargs);
	}

	public void UpdateConfigurationWarnings()
	{
		_object.UpdateConfigurationWarnings();
	}

	public Variant CallDeferredThreadGroup(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallDeferredThreadGroup(@method, varargs);
	}

	public void SetDeferredThreadGroup(Godot.StringName @property, Variant @value)
	{
		_object.SetDeferredThreadGroup(@property, @value);
	}

	public void NotifyDeferredThreadGroup(int @what)
	{
		_object.NotifyDeferredThreadGroup(@what);
	}

	public Variant CallThreadSafe(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallThreadSafe(@method, varargs);
	}

	public void SetThreadSafe(Godot.StringName @property, Variant @value)
	{
		_object.SetThreadSafe(@property, @value);
	}

	public void NotifyThreadSafe(int @what)
	{
		_object.NotifyThreadSafe(@what);
	}

	public void Free()
	{
		_object.Free();
	}

	public string GetClass()
	{
		return _object.GetClass();
	}

	public bool IsClass(string @class)
	{
		return _object.IsClass(@class);
	}

	public void Set(Godot.StringName @property, Variant @value)
	{
		_object.Set(@property, @value);
	}

	public Variant Get(Godot.StringName @property)
	{
		return _object.Get(@property);
	}

	public void SetIndexed(Godot.NodePath @property_path, Variant @value)
	{
		_object.SetIndexed(@property_path, @value);
	}

	public Variant GetIndexed(Godot.NodePath @property_path)
	{
		return _object.GetIndexed(@property_path);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetPropertyList()
	{
		return _object.GetPropertyList();
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetMethodList()
	{
		return _object.GetMethodList();
	}

	public bool PropertyCanRevert(Godot.StringName @property)
	{
		return _object.PropertyCanRevert(@property);
	}

	public Variant PropertyGetRevert(Godot.StringName @property)
	{
		return _object.PropertyGetRevert(@property);
	}

	public void Notification(int @what, bool @reversed = false)
	{
		_object.Notification(@what, @reversed);
	}

	public override string ToString()
	{
		return _object.ToString();
	}

	public ulong GetInstanceId()
	{
		return _object.GetInstanceId();
	}

	public void SetScript(Variant @script)
	{
		_object.SetScript(@script);
	}

	public Variant GetScript()
	{
		return _object.GetScript();
	}

	public void SetMeta(Godot.StringName @name, Variant @value)
	{
		_object.SetMeta(@name, @value);
	}

	public void RemoveMeta(Godot.StringName @name)
	{
		_object.RemoveMeta(@name);
	}

	public Variant GetMeta(Godot.StringName @name, Variant @default = default)
	{
		return _object.GetMeta(@name, @default);
	}

	public bool HasMeta(Godot.StringName @name)
	{
		return _object.HasMeta(@name);
	}

	public Godot.Collections.Array<StringName> GetMetaList()
	{
		return _object.GetMetaList();
	}

	public void AddUserSignal(string @signal, Godot.Collections.Array @arguments = null)
	{
		@arguments ??= new();
		_object.AddUserSignal(@signal, @arguments);
	}

	public bool HasUserSignal(Godot.StringName @signal)
	{
		return _object.HasUserSignal(@signal);
	}

	public void RemoveUserSignal(Godot.StringName @signal)
	{
		_object.RemoveUserSignal(@signal);
	}

	public Godot.Error EmitSignal(Godot.StringName @signal, params Variant[] varargs)
	{
		return _object.EmitSignal(@signal, varargs);
	}

	public Variant Call(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.Call(@method, varargs);
	}

	public Variant CallDeferred(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallDeferred(@method, varargs);
	}

	public void SetDeferred(Godot.StringName @property, Variant @value)
	{
		_object.SetDeferred(@property, @value);
	}

	public Variant Callv(Godot.StringName @method, Godot.Collections.Array @arg_array)
	{
		return _object.Callv(@method, @arg_array);
	}

	public bool HasMethod(Godot.StringName @method)
	{
		return _object.HasMethod(@method);
	}

	public int GetMethodArgumentCount(Godot.StringName @method)
	{
		return _object.GetMethodArgumentCount(@method);
	}

	public bool HasSignal(Godot.StringName @signal)
	{
		return _object.HasSignal(@signal);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetSignalList()
	{
		return _object.GetSignalList();
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetSignalConnectionList(Godot.StringName @signal)
	{
		return _object.GetSignalConnectionList(@signal);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetIncomingConnections()
	{
		return _object.GetIncomingConnections();
	}

	public Godot.Error Connect(Godot.StringName @signal, Godot.Callable @callable, uint @flags = (uint)0)
	{
		return _object.Connect(@signal, @callable, @flags);
	}

	public void Disconnect(Godot.StringName @signal, Godot.Callable @callable)
	{
		_object.Disconnect(@signal, @callable);
	}

	public bool IsConnected(Godot.StringName @signal, Godot.Callable @callable)
	{
		return _object.IsConnected(@signal, @callable);
	}

	public bool HasConnections(Godot.StringName @signal)
	{
		return _object.HasConnections(@signal);
	}

	public void SetBlockSignals(bool @enable)
	{
		_object.SetBlockSignals(@enable);
	}

	public bool IsBlockingSignals()
	{
		return _object.IsBlockingSignals();
	}

	public void NotifyPropertyListChanged()
	{
		_object.NotifyPropertyListChanged();
	}

	public void SetMessageTranslation(bool @enable)
	{
		_object.SetMessageTranslation(@enable);
	}

	public bool CanTranslateMessages()
	{
		return _object.CanTranslateMessages();
	}

	public string Tr(Godot.StringName @message, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.Tr(@message, @context);
	}

	public string TrN(Godot.StringName @message, Godot.StringName @plural_message, int @n, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.TrN(@message, @plural_message, @n, @context);
	}

	public Godot.StringName GetTranslationDomain()
	{
		return _object.GetTranslationDomain();
	}

	public void SetTranslationDomain(Godot.StringName @domain)
	{
		_object.SetTranslationDomain(@domain);
	}

	public bool IsQueuedForDeletion()
	{
		return _object.IsQueuedForDeletion();
	}

	public void CancelFree()
	{
		_object.CancelFree();
	}

	#endregion

	#region Signals

	public event Action<byte[]> DataReceived
	{
		add
		{
			Connect(SignalName.DataReceived, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.DataReceived, Callable.From(value));
		}
	}

	public event Action<int, int> Exited
	{
		add
		{
			Connect(SignalName.Exited, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Exited, Callable.From(value));
		}
	}

	#endregion

	#region Inherited Signals

	public event Action Ready
	{
		add
		{
			Connect(SignalName.Ready, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Ready, Callable.From(value));
		}
	}

	public event Action Renamed
	{
		add
		{
			Connect(SignalName.Renamed, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Renamed, Callable.From(value));
		}
	}

	public event Action TreeEntered
	{
		add
		{
			Connect(SignalName.TreeEntered, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeEntered, Callable.From(value));
		}
	}

	public event Action TreeExiting
	{
		add
		{
			Connect(SignalName.TreeExiting, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeExiting, Callable.From(value));
		}
	}

	public event Action TreeExited
	{
		add
		{
			Connect(SignalName.TreeExited, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeExited, Callable.From(value));
		}
	}

	public event Action<Node> ChildEnteredTree
	{
		add
		{
			Connect(SignalName.ChildEnteredTree, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildEnteredTree, Callable.From(value));
		}
	}

	public event Action<Node> ChildExitingTree
	{
		add
		{
			Connect(SignalName.ChildExitingTree, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildExitingTree, Callable.From(value));
		}
	}

	public event Action ChildOrderChanged
	{
		add
		{
			Connect(SignalName.ChildOrderChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildOrderChanged, Callable.From(value));
		}
	}

	public event Action<Node> ReplacingBy
	{
		add
		{
			Connect(SignalName.ReplacingBy, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ReplacingBy, Callable.From(value));
		}
	}

	public event Action<Node> EditorDescriptionChanged
	{
		add
		{
			Connect(SignalName.EditorDescriptionChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.EditorDescriptionChanged, Callable.From(value));
		}
	}

	public event Action EditorStateChanged
	{
		add
		{
			Connect(SignalName.EditorStateChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.EditorStateChanged, Callable.From(value));
		}
	}

	public event Action ScriptChanged
	{
		add
		{
			Connect(SignalName.ScriptChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ScriptChanged, Callable.From(value));
		}
	}

	public event Action PropertyListChanged
	{
		add
		{
			Connect(SignalName.PropertyListChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.PropertyListChanged, Callable.From(value));
		}
	}

	#endregion
}
