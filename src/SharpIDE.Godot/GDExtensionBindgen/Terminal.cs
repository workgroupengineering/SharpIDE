// This code was automatically generated by GDExtension C# Bindgen
using System;
using System.Diagnostics.CodeAnalysis;
using Godot;

namespace GDExtensionBindgen;

#nullable disable

public class Terminal
{
	// Engine object used for calling engine methods
	protected Control _object;

	public Terminal() : this(NativeName)
	{
	}
	protected Terminal(StringName @class) : this(ClassDB.Instantiate(@class))
	{
	}
	protected Terminal(Variant variant) : this((Control) variant)
	{
	}
	public Terminal([NotNull] Control @object)
	{
		_object = @object;
	}

	public static implicit operator Control(Terminal self) => self?._object;
	public static implicit operator Variant(Terminal self) => self?._object;
	public static explicit operator Terminal(Variant variant) => variant.AsGodotObject() != null ? new(variant) : null;

	public class PropertyName : Control.PropertyName
	{
		public static readonly StringName MaxScrollback = "max_scrollback";
		public static readonly StringName InverseMode = "inverse_mode";
		public static readonly StringName BellMuted = "bell_muted";
		public static readonly StringName BellCooldown = "bell_cooldown";
		public static readonly StringName BlinkOnTime = "blink_on_time";
		public static readonly StringName BlinkOffTime = "blink_off_time";
		public static readonly StringName CopyOnSelection = "copy_on_selection";
	}

	public class MethodName : Control.MethodName
	{
		public static readonly StringName GetCols = "get_cols";
		public static readonly StringName GetRows = "get_rows";
		public static readonly StringName GetMaxScrollback = "get_max_scrollback";
		public static readonly StringName SetMaxScrollback = "set_max_scrollback";
		public static readonly StringName GetInverseMode = "get_inverse_mode";
		public static readonly StringName SetInverseMode = "set_inverse_mode";
		public static readonly StringName GetBellMuted = "get_bell_muted";
		public static readonly StringName SetBellMuted = "set_bell_muted";
		public static readonly StringName GetBellCooldown = "get_bell_cooldown";
		public static readonly StringName SetBellCooldown = "set_bell_cooldown";
		public static readonly StringName GetBlinkOnTime = "get_blink_on_time";
		public static readonly StringName SetBlinkOnTime = "set_blink_on_time";
		public static readonly StringName GetBlinkOffTime = "get_blink_off_time";
		public static readonly StringName SetBlinkOffTime = "set_blink_off_time";
		public static readonly StringName Select = "select";
		public static readonly StringName CopyAll = "copy_all";
		public static readonly StringName CopySelection = "copy_selection";
		public static readonly StringName SetCopyOnSelection = "set_copy_on_selection";
		public static readonly StringName GetCopyOnSelection = "get_copy_on_selection";
		public static readonly StringName Clear = "clear";
		public static readonly StringName Write = "write";
		public static readonly StringName GetCursorPos = "get_cursor_pos";
		public static readonly StringName GetCellSize = "get_cell_size";
	}

	public class SignalName : Control.SignalName
	{
		public static readonly StringName DataSent = "data_sent";
		public static readonly StringName KeyPressed = "key_pressed";
		public static readonly StringName SizeChanged = "size_changed";
		public static readonly StringName Bell = "bell";
	}

	private static readonly StringName NativeName = "Terminal";

	#region Enums

	public enum InverseModeEnum : long
	{
		Invert = 0L,
		Swap = 1L,
	}

	#endregion

	#region Properties

	public int MaxScrollback
	{
		get => (int)_object.Get(PropertyName.MaxScrollback);
		set => _object.Set(PropertyName.MaxScrollback, value);
	}

	public int InverseMode
	{
		get => (int)_object.Get(PropertyName.InverseMode);
		set => _object.Set(PropertyName.InverseMode, value);
	}

	public bool BellMuted
	{
		get => (bool)_object.Get(PropertyName.BellMuted);
		set => _object.Set(PropertyName.BellMuted, value);
	}

	public float BellCooldown
	{
		get => (float)_object.Get(PropertyName.BellCooldown);
		set => _object.Set(PropertyName.BellCooldown, value);
	}

	public float BlinkOnTime
	{
		get => (float)_object.Get(PropertyName.BlinkOnTime);
		set => _object.Set(PropertyName.BlinkOnTime, value);
	}

	public float BlinkOffTime
	{
		get => (float)_object.Get(PropertyName.BlinkOffTime);
		set => _object.Set(PropertyName.BlinkOffTime, value);
	}

	public bool CopyOnSelection
	{
		get => (bool)_object.Get(PropertyName.CopyOnSelection);
		set => _object.Set(PropertyName.CopyOnSelection, value);
	}

	#endregion

	#region Inherited Properties

	public bool ClipContents
	{
		get => _object.ClipContents;
		set => _object.ClipContents = value;
	}

	public Godot.Vector2 CustomMinimumSize
	{
		get => _object.CustomMinimumSize;
		set => _object.CustomMinimumSize = value;
	}

	public Godot.Control.LayoutDirectionEnum LayoutDirection
	{
		get => _object.LayoutDirection;
		set => _object.LayoutDirection = value;
	}

	public int LayoutMode
	{
		get => _object.LayoutMode;
		set => _object.LayoutMode = value;
	}

	public int AnchorsPreset
	{
		get => _object.AnchorsPreset;
		set => _object.AnchorsPreset = value;
	}

	public float AnchorLeft
	{
		get => _object.AnchorLeft;
		set => _object.AnchorLeft = value;
	}

	public float AnchorTop
	{
		get => _object.AnchorTop;
		set => _object.AnchorTop = value;
	}

	public float AnchorRight
	{
		get => _object.AnchorRight;
		set => _object.AnchorRight = value;
	}

	public float AnchorBottom
	{
		get => _object.AnchorBottom;
		set => _object.AnchorBottom = value;
	}

	public float OffsetLeft
	{
		get => _object.OffsetLeft;
		set => _object.OffsetLeft = value;
	}

	public float OffsetTop
	{
		get => _object.OffsetTop;
		set => _object.OffsetTop = value;
	}

	public float OffsetRight
	{
		get => _object.OffsetRight;
		set => _object.OffsetRight = value;
	}

	public float OffsetBottom
	{
		get => _object.OffsetBottom;
		set => _object.OffsetBottom = value;
	}

	public Godot.Control.GrowDirection GrowHorizontal
	{
		get => _object.GrowHorizontal;
		set => _object.GrowHorizontal = value;
	}

	public Godot.Control.GrowDirection GrowVertical
	{
		get => _object.GrowVertical;
		set => _object.GrowVertical = value;
	}

	public Godot.Vector2 Size
	{
		get => _object.Size;
		set => _object.Size = value;
	}

	public Godot.Vector2 Position
	{
		get => _object.Position;
		set => _object.Position = value;
	}

	public Godot.Vector2 GlobalPosition
	{
		get => _object.GlobalPosition;
		set => _object.GlobalPosition = value;
	}

	public float Rotation
	{
		get => _object.Rotation;
		set => _object.Rotation = value;
	}

	public float RotationDegrees
	{
		get => _object.RotationDegrees;
		set => _object.RotationDegrees = value;
	}

	public Godot.Vector2 Scale
	{
		get => _object.Scale;
		set => _object.Scale = value;
	}

	public Godot.Vector2 PivotOffset
	{
		get => _object.PivotOffset;
		set => _object.PivotOffset = value;
	}

	public Godot.Control.SizeFlags SizeFlagsHorizontal
	{
		get => _object.SizeFlagsHorizontal;
		set => _object.SizeFlagsHorizontal = value;
	}

	public Godot.Control.SizeFlags SizeFlagsVertical
	{
		get => _object.SizeFlagsVertical;
		set => _object.SizeFlagsVertical = value;
	}

	public float SizeFlagsStretchRatio
	{
		get => _object.SizeFlagsStretchRatio;
		set => _object.SizeFlagsStretchRatio = value;
	}

	public bool LocalizeNumeralSystem
	{
		get => _object.LocalizeNumeralSystem;
		set => _object.LocalizeNumeralSystem = value;
	}

	[Obsolete("Use 'Godot.Node.AutoTranslateMode' and 'Godot.Node.CanAutoTranslate()' instead.")]
	public bool AutoTranslate
	{
		get => _object.AutoTranslate;
		set => _object.AutoTranslate = value;
	}

	public string TooltipText
	{
		get => _object.TooltipText;
		set => _object.TooltipText = value;
	}

	public Node.AutoTranslateModeEnum TooltipAutoTranslateMode
	{
		get => _object.TooltipAutoTranslateMode;
		set => _object.TooltipAutoTranslateMode = value;
	}

	public Godot.NodePath FocusNeighborLeft
	{
		get => _object.FocusNeighborLeft;
		set => _object.FocusNeighborLeft = value;
	}

	public Godot.NodePath FocusNeighborTop
	{
		get => _object.FocusNeighborTop;
		set => _object.FocusNeighborTop = value;
	}

	public Godot.NodePath FocusNeighborRight
	{
		get => _object.FocusNeighborRight;
		set => _object.FocusNeighborRight = value;
	}

	public Godot.NodePath FocusNeighborBottom
	{
		get => _object.FocusNeighborBottom;
		set => _object.FocusNeighborBottom = value;
	}

	public Godot.NodePath FocusNext
	{
		get => _object.FocusNext;
		set => _object.FocusNext = value;
	}

	public Godot.NodePath FocusPrevious
	{
		get => _object.FocusPrevious;
		set => _object.FocusPrevious = value;
	}

	public Control.FocusModeEnum FocusMode
	{
		get => _object.FocusMode;
		set => _object.FocusMode = value;
	}

	public Control.MouseFilterEnum MouseFilter
	{
		get => _object.MouseFilter;
		set => _object.MouseFilter = value;
	}

	public bool MouseForcePassScrollEvents
	{
		get => _object.MouseForcePassScrollEvents;
		set => _object.MouseForcePassScrollEvents = value;
	}

	public Control.CursorShape MouseDefaultCursorShape
	{
		get => _object.MouseDefaultCursorShape;
		set => _object.MouseDefaultCursorShape = value;
	}

	public Node ShortcutContext
	{
		get => _object.ShortcutContext;
		set => _object.ShortcutContext = value;
	}

	public Theme Theme
	{
		get => _object.Theme;
		set => _object.Theme = value;
	}

	public string ThemeTypeVariation
	{
		get => _object.ThemeTypeVariation;
		set => _object.ThemeTypeVariation = value;
	}

	public bool Visible
	{
		get => _object.Visible;
		set => _object.Visible = value;
	}

	public Godot.Color Modulate
	{
		get => _object.Modulate;
		set => _object.Modulate = value;
	}

	public Godot.Color SelfModulate
	{
		get => _object.SelfModulate;
		set => _object.SelfModulate = value;
	}

	public bool ShowBehindParent
	{
		get => _object.ShowBehindParent;
		set => _object.ShowBehindParent = value;
	}

	public bool TopLevel
	{
		get => _object.TopLevel;
		set => _object.TopLevel = value;
	}

	public CanvasItem.ClipChildrenMode ClipChildren
	{
		get => _object.ClipChildren;
		set => _object.ClipChildren = value;
	}

	public int LightMask
	{
		get => _object.LightMask;
		set => _object.LightMask = value;
	}

	public uint VisibilityLayer
	{
		get => _object.VisibilityLayer;
		set => _object.VisibilityLayer = value;
	}

	public int ZIndex
	{
		get => _object.ZIndex;
		set => _object.ZIndex = value;
	}

	public bool ZAsRelative
	{
		get => _object.ZAsRelative;
		set => _object.ZAsRelative = value;
	}

	public bool YSortEnabled
	{
		get => _object.YSortEnabled;
		set => _object.YSortEnabled = value;
	}

	public CanvasItem.TextureFilterEnum TextureFilter
	{
		get => _object.TextureFilter;
		set => _object.TextureFilter = value;
	}

	public CanvasItem.TextureRepeatEnum TextureRepeat
	{
		get => _object.TextureRepeat;
		set => _object.TextureRepeat = value;
	}

	public Material Material
	{
		get => _object.Material;
		set => _object.Material = value;
	}

	public bool UseParentMaterial
	{
		get => _object.UseParentMaterial;
		set => _object.UseParentMaterial = value;
	}

	public Godot.StringName Name
	{
		get => _object.Name;
		set => _object.Name = value;
	}

	public bool UniqueNameInOwner
	{
		get => _object.UniqueNameInOwner;
		set => _object.UniqueNameInOwner = value;
	}

	public string SceneFilePath
	{
		get => _object.SceneFilePath;
		set => _object.SceneFilePath = value;
	}

	public Node Owner
	{
		get => _object.Owner;
		set => _object.Owner = value;
	}

	public MultiplayerApi Multiplayer
	{
		get => _object.Multiplayer;
	}

	public Node.ProcessModeEnum ProcessMode
	{
		get => _object.ProcessMode;
		set => _object.ProcessMode = value;
	}

	public int ProcessPriority
	{
		get => _object.ProcessPriority;
		set => _object.ProcessPriority = value;
	}

	public int ProcessPhysicsPriority
	{
		get => _object.ProcessPhysicsPriority;
		set => _object.ProcessPhysicsPriority = value;
	}

	public Node.ProcessThreadGroupEnum ProcessThreadGroup
	{
		get => _object.ProcessThreadGroup;
		set => _object.ProcessThreadGroup = value;
	}

	public int ProcessThreadGroupOrder
	{
		get => _object.ProcessThreadGroupOrder;
		set => _object.ProcessThreadGroupOrder = value;
	}

	public Node.ProcessThreadMessagesEnum ProcessThreadMessages
	{
		get => _object.ProcessThreadMessages;
		set => _object.ProcessThreadMessages = value;
	}

	public Node.PhysicsInterpolationModeEnum PhysicsInterpolationMode
	{
		get => _object.PhysicsInterpolationMode;
		set => _object.PhysicsInterpolationMode = value;
	}

	public Node.AutoTranslateModeEnum AutoTranslateMode
	{
		get => _object.AutoTranslateMode;
		set => _object.AutoTranslateMode = value;
	}

	public string EditorDescription
	{
		get => _object.EditorDescription;
		set => _object.EditorDescription = value;
	}

	#endregion

	#region Methods

	public int GetCols()
	{
		return (int)_object.Call(MethodName.GetCols);
	}

	public int GetRows()
	{
		return (int)_object.Call(MethodName.GetRows);
	}

	public int GetMaxScrollback()
	{
		return (int)_object.Call(MethodName.GetMaxScrollback);
	}

	public void SetMaxScrollback(int @max_scrollback)
	{
		_object.Call(MethodName.SetMaxScrollback, @max_scrollback);
	}

	public int GetInverseMode()
	{
		return (int)_object.Call(MethodName.GetInverseMode);
	}

	public void SetInverseMode(int @inverse_mode)
	{
		_object.Call(MethodName.SetInverseMode, @inverse_mode);
	}

	public bool GetBellMuted()
	{
		return (bool)_object.Call(MethodName.GetBellMuted);
	}

	public void SetBellMuted(bool @muted)
	{
		_object.Call(MethodName.SetBellMuted, @muted);
	}

	public float GetBellCooldown()
	{
		return (float)_object.Call(MethodName.GetBellCooldown);
	}

	public void SetBellCooldown(float @time)
	{
		_object.Call(MethodName.SetBellCooldown, @time);
	}

	public float GetBlinkOnTime()
	{
		return (float)_object.Call(MethodName.GetBlinkOnTime);
	}

	public void SetBlinkOnTime(float @time)
	{
		_object.Call(MethodName.SetBlinkOnTime, @time);
	}

	public float GetBlinkOffTime()
	{
		return (float)_object.Call(MethodName.GetBlinkOffTime);
	}

	public void SetBlinkOffTime(float @time)
	{
		_object.Call(MethodName.SetBlinkOffTime, @time);
	}

	public void Select(int @from_line, int @from_column, int @to_line, int @to_column)
	{
		_object.Call(MethodName.Select, @from_line, @from_column, @to_line, @to_column);
	}

	public string CopyAll()
	{
		return (string)_object.Call(MethodName.CopyAll);
	}

	public string CopySelection()
	{
		return (string)_object.Call(MethodName.CopySelection);
	}

	public void SetCopyOnSelection(bool @enabled)
	{
		_object.Call(MethodName.SetCopyOnSelection, @enabled);
	}

	public bool GetCopyOnSelection()
	{
		return (bool)_object.Call(MethodName.GetCopyOnSelection);
	}

	public void Clear()
	{
		_object.Call(MethodName.Clear);
	}

	public string Write(Variant @data)
	{
		return (string)_object.Call(MethodName.Write, @data);
	}

	public Godot.Vector2I GetCursorPos()
	{
		return (Godot.Vector2I)_object.Call(MethodName.GetCursorPos);
	}

	public Godot.Vector2 GetCellSize()
	{
		return (Godot.Vector2)_object.Call(MethodName.GetCellSize);
	}

	#endregion

	#region Inherited Methods

	public void AcceptEvent()
	{
		_object.AcceptEvent();
	}

	public Godot.Vector2 GetMinimumSize()
	{
		return _object.GetMinimumSize();
	}

	public Godot.Vector2 GetCombinedMinimumSize()
	{
		return _object.GetCombinedMinimumSize();
	}

	public void SetAnchorsPreset(Control.LayoutPreset @preset, bool @keep_offsets = false)
	{
		_object.SetAnchorsPreset(@preset, @keep_offsets);
	}

	public void SetOffsetsPreset(Control.LayoutPreset @preset, Control.LayoutPresetMode @resize_mode = (Control.LayoutPresetMode)0, int @margin = 0)
	{
		_object.SetOffsetsPreset(@preset, @resize_mode, @margin);
	}

	public void SetAnchorsAndOffsetsPreset(Control.LayoutPreset @preset, Control.LayoutPresetMode @resize_mode = (Control.LayoutPresetMode)0, int @margin = 0)
	{
		_object.SetAnchorsAndOffsetsPreset(@preset, @resize_mode, @margin);
	}

	public void SetAnchor(Side @side, float @anchor, bool @keep_offset = false, bool @push_opposite_anchor = true)
	{
		_object.SetAnchor(@side, @anchor, @keep_offset, @push_opposite_anchor);
	}

	public float GetAnchor(Side @side)
	{
		return _object.GetAnchor(@side);
	}

	public void SetOffset(Side @side, float @offset)
	{
		_object.SetOffset(@side, @offset);
	}

	public float GetOffset(Side @offset)
	{
		return _object.GetOffset(@offset);
	}

	public void SetAnchorAndOffset(Side @side, float @anchor, float @offset, bool @push_opposite_anchor = false)
	{
		_object.SetAnchorAndOffset(@side, @anchor, @offset, @push_opposite_anchor);
	}

	public void SetBegin(Godot.Vector2 @position)
	{
		_object.SetBegin(@position);
	}

	public void SetEnd(Godot.Vector2 @position)
	{
		_object.SetEnd(@position);
	}

	public void SetPosition(Godot.Vector2 @position, bool @keep_offsets = false)
	{
		_object.SetPosition(@position, @keep_offsets);
	}

	public void SetSize(Godot.Vector2 @size, bool @keep_offsets = false)
	{
		_object.SetSize(@size, @keep_offsets);
	}

	public void ResetSize()
	{
		_object.ResetSize();
	}

	public void SetCustomMinimumSize(Godot.Vector2 @size)
	{
		_object.SetCustomMinimumSize(@size);
	}

	public void SetGlobalPosition(Godot.Vector2 @position, bool @keep_offsets = false)
	{
		_object.SetGlobalPosition(@position, @keep_offsets);
	}

	public void SetRotation(float @radians)
	{
		_object.SetRotation(@radians);
	}

	public void SetRotationDegrees(float @degrees)
	{
		_object.SetRotationDegrees(@degrees);
	}

	public void SetScale(Godot.Vector2 @scale)
	{
		_object.SetScale(@scale);
	}

	public void SetPivotOffset(Godot.Vector2 @pivot_offset)
	{
		_object.SetPivotOffset(@pivot_offset);
	}

	public Godot.Vector2 GetBegin()
	{
		return _object.GetBegin();
	}

	public Godot.Vector2 GetEnd()
	{
		return _object.GetEnd();
	}

	public Godot.Vector2 GetPosition()
	{
		return _object.GetPosition();
	}

	public Godot.Vector2 GetSize()
	{
		return _object.GetSize();
	}

	public float GetRotation()
	{
		return _object.GetRotation();
	}

	public float GetRotationDegrees()
	{
		return _object.GetRotationDegrees();
	}

	public Godot.Vector2 GetScale()
	{
		return _object.GetScale();
	}

	public Godot.Vector2 GetPivotOffset()
	{
		return _object.GetPivotOffset();
	}

	public Godot.Vector2 GetCustomMinimumSize()
	{
		return _object.GetCustomMinimumSize();
	}

	public Godot.Vector2 GetParentAreaSize()
	{
		return _object.GetParentAreaSize();
	}

	public Godot.Vector2 GetGlobalPosition()
	{
		return _object.GetGlobalPosition();
	}

	public Godot.Vector2 GetScreenPosition()
	{
		return _object.GetScreenPosition();
	}

	public Godot.Rect2 GetRect()
	{
		return _object.GetRect();
	}

	public Godot.Rect2 GetGlobalRect()
	{
		return _object.GetGlobalRect();
	}

	public void SetFocusMode(Control.FocusModeEnum @mode)
	{
		_object.SetFocusMode(@mode);
	}

	public Control.FocusModeEnum GetFocusMode()
	{
		return _object.GetFocusMode();
	}

	public bool HasFocus()
	{
		return _object.HasFocus();
	}

	public void GrabFocus()
	{
		_object.GrabFocus();
	}

	public void ReleaseFocus()
	{
		_object.ReleaseFocus();
	}

	public Control FindPrevValidFocus()
	{
		return _object.FindPrevValidFocus();
	}

	public Control FindNextValidFocus()
	{
		return _object.FindNextValidFocus();
	}

	public Control FindValidFocusNeighbor(Side @side)
	{
		return _object.FindValidFocusNeighbor(@side);
	}

	public void SetHSizeFlags(Control.SizeFlags @flags)
	{
		_object.SetHSizeFlags(@flags);
	}

	public Control.SizeFlags GetHSizeFlags()
	{
		return _object.GetHSizeFlags();
	}

	public void SetStretchRatio(float @ratio)
	{
		_object.SetStretchRatio(@ratio);
	}

	public float GetStretchRatio()
	{
		return _object.GetStretchRatio();
	}

	public void SetVSizeFlags(Control.SizeFlags @flags)
	{
		_object.SetVSizeFlags(@flags);
	}

	public Control.SizeFlags GetVSizeFlags()
	{
		return _object.GetVSizeFlags();
	}

	public void SetTheme(Theme @theme)
	{
		_object.SetTheme(@theme);
	}

	public Theme GetTheme()
	{
		return _object.GetTheme();
	}

	public void SetThemeTypeVariation(Godot.StringName @theme_type)
	{
		_object.SetThemeTypeVariation(@theme_type);
	}

	public Godot.StringName GetThemeTypeVariation()
	{
		return _object.GetThemeTypeVariation();
	}

	public void BeginBulkThemeOverride()
	{
		_object.BeginBulkThemeOverride();
	}

	public void EndBulkThemeOverride()
	{
		_object.EndBulkThemeOverride();
	}

	public void AddThemeIconOverride(Godot.StringName @name, Texture2D @texture)
	{
		_object.AddThemeIconOverride(@name, @texture);
	}

	public void AddThemeStyleboxOverride(Godot.StringName @name, StyleBox @stylebox)
	{
		_object.AddThemeStyleboxOverride(@name, @stylebox);
	}

	public void AddThemeFontOverride(Godot.StringName @name, Font @font)
	{
		_object.AddThemeFontOverride(@name, @font);
	}

	public void AddThemeFontSizeOverride(Godot.StringName @name, int @font_size)
	{
		_object.AddThemeFontSizeOverride(@name, @font_size);
	}

	public void AddThemeColorOverride(Godot.StringName @name, Godot.Color @color)
	{
		_object.AddThemeColorOverride(@name, @color);
	}

	public void AddThemeConstantOverride(Godot.StringName @name, int @constant)
	{
		_object.AddThemeConstantOverride(@name, @constant);
	}

	public void RemoveThemeIconOverride(Godot.StringName @name)
	{
		_object.RemoveThemeIconOverride(@name);
	}

	public void RemoveThemeStyleboxOverride(Godot.StringName @name)
	{
		_object.RemoveThemeStyleboxOverride(@name);
	}

	public void RemoveThemeFontOverride(Godot.StringName @name)
	{
		_object.RemoveThemeFontOverride(@name);
	}

	public void RemoveThemeFontSizeOverride(Godot.StringName @name)
	{
		_object.RemoveThemeFontSizeOverride(@name);
	}

	public void RemoveThemeColorOverride(Godot.StringName @name)
	{
		_object.RemoveThemeColorOverride(@name);
	}

	public void RemoveThemeConstantOverride(Godot.StringName @name)
	{
		_object.RemoveThemeConstantOverride(@name);
	}

	public Texture2D GetThemeIcon(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeIcon(@name, @theme_type);
	}

	public StyleBox GetThemeStylebox(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeStylebox(@name, @theme_type);
	}

	public Font GetThemeFont(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeFont(@name, @theme_type);
	}

	public int GetThemeFontSize(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeFontSize(@name, @theme_type);
	}

	public Godot.Color GetThemeColor(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeColor(@name, @theme_type);
	}

	public int GetThemeConstant(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.GetThemeConstant(@name, @theme_type);
	}

	public bool HasThemeIconOverride(Godot.StringName @name)
	{
		return _object.HasThemeIconOverride(@name);
	}

	public bool HasThemeStyleboxOverride(Godot.StringName @name)
	{
		return _object.HasThemeStyleboxOverride(@name);
	}

	public bool HasThemeFontOverride(Godot.StringName @name)
	{
		return _object.HasThemeFontOverride(@name);
	}

	public bool HasThemeFontSizeOverride(Godot.StringName @name)
	{
		return _object.HasThemeFontSizeOverride(@name);
	}

	public bool HasThemeColorOverride(Godot.StringName @name)
	{
		return _object.HasThemeColorOverride(@name);
	}

	public bool HasThemeConstantOverride(Godot.StringName @name)
	{
		return _object.HasThemeConstantOverride(@name);
	}

	public bool HasThemeIcon(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeIcon(@name, @theme_type);
	}

	public bool HasThemeStylebox(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeStylebox(@name, @theme_type);
	}

	public bool HasThemeFont(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeFont(@name, @theme_type);
	}

	public bool HasThemeFontSize(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeFontSize(@name, @theme_type);
	}

	public bool HasThemeColor(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeColor(@name, @theme_type);
	}

	public bool HasThemeConstant(Godot.StringName @name, Godot.StringName @theme_type = null)
	{
		@theme_type ??= "";
		return _object.HasThemeConstant(@name, @theme_type);
	}

	public float GetThemeDefaultBaseScale()
	{
		return _object.GetThemeDefaultBaseScale();
	}

	public Font GetThemeDefaultFont()
	{
		return _object.GetThemeDefaultFont();
	}

	public int GetThemeDefaultFontSize()
	{
		return _object.GetThemeDefaultFontSize();
	}

	public Control GetParentControl()
	{
		return _object.GetParentControl();
	}

	public void SetHGrowDirection(Control.GrowDirection @direction)
	{
		_object.SetHGrowDirection(@direction);
	}

	public Control.GrowDirection GetHGrowDirection()
	{
		return _object.GetHGrowDirection();
	}

	public void SetVGrowDirection(Control.GrowDirection @direction)
	{
		_object.SetVGrowDirection(@direction);
	}

	public Control.GrowDirection GetVGrowDirection()
	{
		return _object.GetVGrowDirection();
	}

	public void SetTooltipAutoTranslateMode(Node.AutoTranslateModeEnum @mode)
	{
		_object.SetTooltipAutoTranslateMode(@mode);
	}

	public Node.AutoTranslateModeEnum GetTooltipAutoTranslateMode()
	{
		return _object.GetTooltipAutoTranslateMode();
	}

	public void SetTooltipText(string @hint)
	{
		_object.SetTooltipText(@hint);
	}

	public string GetTooltipText()
	{
		return _object.GetTooltipText();
	}

	public string GetTooltip(Godot.Vector2? @at_position = null)
	{
		@at_position ??= new(0.0f, 0.0f);
		return _object.GetTooltip(@at_position);
	}

	public void SetDefaultCursorShape(Control.CursorShape @shape)
	{
		_object.SetDefaultCursorShape(@shape);
	}

	public Control.CursorShape GetDefaultCursorShape()
	{
		return _object.GetDefaultCursorShape();
	}

	public Control.CursorShape GetCursorShape(Godot.Vector2? @position = null)
	{
		@position ??= new(0.0f, 0.0f);
		return _object.GetCursorShape(@position);
	}

	public void SetFocusNeighbor(Side @side, Godot.NodePath @neighbor)
	{
		_object.SetFocusNeighbor(@side, @neighbor);
	}

	public Godot.NodePath GetFocusNeighbor(Side @side)
	{
		return _object.GetFocusNeighbor(@side);
	}

	public void SetFocusNext(Godot.NodePath @next)
	{
		_object.SetFocusNext(@next);
	}

	public Godot.NodePath GetFocusNext()
	{
		return _object.GetFocusNext();
	}

	public void SetFocusPrevious(Godot.NodePath @previous)
	{
		_object.SetFocusPrevious(@previous);
	}

	public Godot.NodePath GetFocusPrevious()
	{
		return _object.GetFocusPrevious();
	}

	public void ForceDrag(Variant @data, Control @preview)
	{
		_object.ForceDrag(@data, @preview);
	}

	public void SetMouseFilter(Control.MouseFilterEnum @filter)
	{
		_object.SetMouseFilter(@filter);
	}

	public Control.MouseFilterEnum GetMouseFilter()
	{
		return _object.GetMouseFilter();
	}

	public void SetForcePassScrollEvents(bool @force_pass_scroll_events)
	{
		_object.SetForcePassScrollEvents(@force_pass_scroll_events);
	}

	public bool IsForcePassScrollEvents()
	{
		return _object.IsForcePassScrollEvents();
	}

	public void SetClipContents(bool @enable)
	{
		_object.SetClipContents(@enable);
	}

	public bool IsClippingContents()
	{
		return _object.IsClippingContents();
	}

	public void GrabClickFocus()
	{
		_object.GrabClickFocus();
	}

	public void SetDragForwarding(Godot.Callable @drag_func, Godot.Callable @can_drop_func, Godot.Callable @drop_func)
	{
		_object.SetDragForwarding(@drag_func, @can_drop_func, @drop_func);
	}

	public void SetDragPreview(Control @control)
	{
		_object.SetDragPreview(@control);
	}

	public bool IsDragSuccessful()
	{
		return _object.IsDragSuccessful();
	}

	public void WarpMouse(Godot.Vector2 @position)
	{
		_object.WarpMouse(@position);
	}

	public void SetShortcutContext(Node @node)
	{
		_object.SetShortcutContext(@node);
	}

	public Node GetShortcutContext()
	{
		return _object.GetShortcutContext();
	}

	public void UpdateMinimumSize()
	{
		_object.UpdateMinimumSize();
	}

	public void SetLayoutDirection(Control.LayoutDirectionEnum @direction)
	{
		_object.SetLayoutDirection(@direction);
	}

	public Control.LayoutDirectionEnum GetLayoutDirection()
	{
		return _object.GetLayoutDirection();
	}

	public bool IsLayoutRtl()
	{
		return _object.IsLayoutRtl();
	}

	public void SetAutoTranslate(bool @enable)
	{
		_object.SetAutoTranslate(@enable);
	}

	public bool IsAutoTranslating()
	{
		return _object.IsAutoTranslating();
	}

	public void SetLocalizeNumeralSystem(bool @enable)
	{
		_object.SetLocalizeNumeralSystem(@enable);
	}

	public bool IsLocalizingNumeralSystem()
	{
		return _object.IsLocalizingNumeralSystem();
	}

	public Godot.Rid GetCanvasItem()
	{
		return _object.GetCanvasItem();
	}

	public void SetVisible(bool @visible)
	{
		_object.SetVisible(@visible);
	}

	public bool IsVisible()
	{
		return _object.IsVisible();
	}

	public bool IsVisibleInTree()
	{
		return _object.IsVisibleInTree();
	}

	public void Show()
	{
		_object.Show();
	}

	public void Hide()
	{
		_object.Hide();
	}

	public void QueueRedraw()
	{
		_object.QueueRedraw();
	}

	public void MoveToFront()
	{
		_object.MoveToFront();
	}

	public void SetAsTopLevel(bool @enable)
	{
		_object.SetAsTopLevel(@enable);
	}

	public bool IsSetAsTopLevel()
	{
		return _object.IsSetAsTopLevel();
	}

	public void SetLightMask(int @light_mask)
	{
		_object.SetLightMask(@light_mask);
	}

	public int GetLightMask()
	{
		return _object.GetLightMask();
	}

	public void SetModulate(Godot.Color @modulate)
	{
		_object.SetModulate(@modulate);
	}

	public Godot.Color GetModulate()
	{
		return _object.GetModulate();
	}

	public void SetSelfModulate(Godot.Color @self_modulate)
	{
		_object.SetSelfModulate(@self_modulate);
	}

	public Godot.Color GetSelfModulate()
	{
		return _object.GetSelfModulate();
	}

	public void SetZIndex(int @z_index)
	{
		_object.SetZIndex(@z_index);
	}

	public int GetZIndex()
	{
		return _object.GetZIndex();
	}

	public void SetZAsRelative(bool @enable)
	{
		_object.SetZAsRelative(@enable);
	}

	public bool IsZRelative()
	{
		return _object.IsZRelative();
	}

	public void SetYSortEnabled(bool @enabled)
	{
		_object.SetYSortEnabled(@enabled);
	}

	public bool IsYSortEnabled()
	{
		return _object.IsYSortEnabled();
	}

	public void SetDrawBehindParent(bool @enable)
	{
		_object.SetDrawBehindParent(@enable);
	}

	public bool IsDrawBehindParentEnabled()
	{
		return _object.IsDrawBehindParentEnabled();
	}

	public void DrawLine(Godot.Vector2 @from, Godot.Vector2 @to, Godot.Color @color, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawLine(@from, @to, @color, @width, @antialiased);
	}

	public void DrawDashedLine(Godot.Vector2 @from, Godot.Vector2 @to, Godot.Color @color, float @width = -1.0f, float @dash = 2.0f, bool @aligned = true, bool @antialiased = false)
	{
		_object.DrawDashedLine(@from, @to, @color, @width, @dash, @aligned, @antialiased);
	}

	public void DrawPolyline(Godot.Vector2[] @points, Godot.Color @color, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawPolyline(@points, @color, @width, @antialiased);
	}

	public void DrawPolylineColors(Godot.Vector2[] @points, Godot.Color[] @colors, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawPolylineColors(@points, @colors, @width, @antialiased);
	}

	public void DrawArc(Godot.Vector2 @center, float @radius, float @start_angle, float @end_angle, int @point_count, Godot.Color @color, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawArc(@center, @radius, @start_angle, @end_angle, @point_count, @color, @width, @antialiased);
	}

	public void DrawMultiline(Godot.Vector2[] @points, Godot.Color @color, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawMultiline(@points, @color, @width, @antialiased);
	}

	public void DrawMultilineColors(Godot.Vector2[] @points, Godot.Color[] @colors, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawMultilineColors(@points, @colors, @width, @antialiased);
	}

	public void DrawRect(Godot.Rect2 @rect, Godot.Color @color, bool @filled = true, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawRect(@rect, @color, @filled, @width, @antialiased);
	}

	public void DrawCircle(Godot.Vector2 @position, float @radius, Godot.Color @color, bool @filled = true, float @width = -1.0f, bool @antialiased = false)
	{
		_object.DrawCircle(@position, @radius, @color, @filled, @width, @antialiased);
	}

	public void DrawTexture(Texture2D @texture, Godot.Vector2 @position, Godot.Color? @modulate = null)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawTexture(@texture, @position, @modulate);
	}

	public void DrawTextureRect(Texture2D @texture, Godot.Rect2 @rect, bool @tile, Godot.Color? @modulate = null, bool @transpose = false)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawTextureRect(@texture, @rect, @tile, @modulate, @transpose);
	}

	public void DrawTextureRectRegion(Texture2D @texture, Godot.Rect2 @rect, Godot.Rect2 @src_rect, Godot.Color? @modulate = null, bool @transpose = false, bool @clip_uv = true)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawTextureRectRegion(@texture, @rect, @src_rect, @modulate, @transpose, @clip_uv);
	}

	public void DrawMsdfTextureRectRegion(Texture2D @texture, Godot.Rect2 @rect, Godot.Rect2 @src_rect, Godot.Color? @modulate = null, float @outline = 0.0f, float @pixel_range = 4.0f, float @scale = 1.0f)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawMsdfTextureRectRegion(@texture, @rect, @src_rect, @modulate, @outline, @pixel_range, @scale);
	}

	public void DrawLcdTextureRectRegion(Texture2D @texture, Godot.Rect2 @rect, Godot.Rect2 @src_rect, Godot.Color? @modulate = null)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawLcdTextureRectRegion(@texture, @rect, @src_rect, @modulate);
	}

	public void DrawStyleBox(StyleBox @style_box, Godot.Rect2 @rect)
	{
		_object.DrawStyleBox(@style_box, @rect);
	}

	public void DrawPrimitive(Godot.Vector2[] @points, Godot.Color[] @colors, Godot.Vector2[] @uvs, Texture2D @texture = default)
	{
		_object.DrawPrimitive(@points, @colors, @uvs, @texture);
	}

	public void DrawPolygon(Godot.Vector2[] @points, Godot.Color[] @colors, Godot.Vector2[] @uvs = null, Texture2D @texture = default)
	{
		@uvs ??= System.Array.Empty<Godot.Vector2>();
		_object.DrawPolygon(@points, @colors, @uvs, @texture);
	}

	public void DrawColoredPolygon(Godot.Vector2[] @points, Godot.Color @color, Godot.Vector2[] @uvs = null, Texture2D @texture = default)
	{
		@uvs ??= System.Array.Empty<Godot.Vector2>();
		_object.DrawColoredPolygon(@points, @color, @uvs, @texture);
	}

	public void DrawString(Font @font, Godot.Vector2 @pos, string @text, HorizontalAlignment @alignment = (HorizontalAlignment)0, float @width = (float)-1, int @font_size = 16, Godot.Color? @modulate = null, TextServer.JustificationFlag @justification_flags = (TextServer.JustificationFlag)3, TextServer.Direction @direction = (TextServer.Direction)0, TextServer.Orientation @orientation = (TextServer.Orientation)0)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawString(@font, @pos, @text, @alignment, @width, @font_size, @modulate, @justification_flags, @direction, @orientation);
	}

	public void DrawMultilineString(Font @font, Godot.Vector2 @pos, string @text, HorizontalAlignment @alignment = (HorizontalAlignment)0, float @width = (float)-1, int @font_size = 16, int @max_lines = -1, Godot.Color? @modulate = null, TextServer.LineBreakFlag @brk_flags = (TextServer.LineBreakFlag)3, TextServer.JustificationFlag @justification_flags = (TextServer.JustificationFlag)3, TextServer.Direction @direction = (TextServer.Direction)0, TextServer.Orientation @orientation = (TextServer.Orientation)0)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawMultilineString(@font, @pos, @text, (HorizontalAlignment)@alignment, @width, @font_size, @max_lines, @modulate, (TextServer.LineBreakFlag)@brk_flags, @justification_flags, @direction, @orientation);
	}

	public void DrawStringOutline(Font @font, Godot.Vector2 @pos, string @text, HorizontalAlignment @alignment = (HorizontalAlignment)0, float @width = (float)-1, int @font_size = 16, int @size = 1, Godot.Color? @modulate = null, TextServer.JustificationFlag @justification_flags = (TextServer.JustificationFlag)3, TextServer.Direction @direction = (TextServer.Direction)0, TextServer.Orientation @orientation = (TextServer.Orientation)0)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawStringOutline(@font, @pos, @text, (HorizontalAlignment)@alignment, @width, @font_size, @size, @modulate, @justification_flags, @direction, @orientation);
	}

	public void DrawMultilineStringOutline(Font @font, Godot.Vector2 @pos, string @text, HorizontalAlignment @alignment = (HorizontalAlignment)0, float @width = (float)-1, int @font_size = 16, int @max_lines = -1, int @size = 1, Godot.Color? @modulate = null, TextServer.LineBreakFlag @brk_flags = (TextServer.LineBreakFlag)3, TextServer.JustificationFlag @justification_flags = (TextServer.JustificationFlag)3, TextServer.Direction @direction = (TextServer.Direction)0, TextServer.Orientation @orientation = (TextServer.Orientation)0)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawMultilineStringOutline(@font, @pos, @text, (HorizontalAlignment)@alignment, @width, @font_size, @max_lines, @size, @modulate, @brk_flags, @justification_flags, @direction, @orientation);
	}

	public void DrawChar(Font @font, Godot.Vector2 @pos, string @char, int @font_size = 16, Godot.Color? @modulate = null)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawChar(@font, @pos, @char, @font_size, @modulate);
	}

	public void DrawCharOutline(Font @font, Godot.Vector2 @pos, string @char, int @font_size = 16, int @size = -1, Godot.Color? @modulate = null)
	{
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawCharOutline(@font, @pos, @char, @font_size, @size, @modulate);
	}

	public void DrawMesh(Mesh @mesh, Texture2D @texture, Godot.Transform2D? @transform = null, Godot.Color? @modulate = null)
	{
		@transform ??= Godot.Transform2D.Identity;
		@modulate ??= new(1.0f, 1.0f, 1.0f, 1.0f);
		_object.DrawMesh(@mesh, @texture, @transform, @modulate);
	}

	public void DrawMultimesh(MultiMesh @multimesh, Texture2D @texture)
	{
		_object.DrawMultimesh(@multimesh, @texture);
	}

	public void DrawSetTransform(Godot.Vector2 @position, float @rotation = 0.0f, Godot.Vector2? @scale = null)
	{
		@scale ??= new(1.0f, 1.0f);
		_object.DrawSetTransform(@position, @rotation, @scale);
	}

	public void DrawSetTransformMatrix(Godot.Transform2D @xform)
	{
		_object.DrawSetTransformMatrix(@xform);
	}

	public void DrawAnimationSlice(float @animation_length, float @slice_begin, float @slice_end, float @offset = 0.0f)
	{
		_object.DrawAnimationSlice(@animation_length, @slice_begin, @slice_end, @offset);
	}

	public void DrawEndAnimation()
	{
		_object.DrawEndAnimation();
	}

	public Godot.Transform2D GetTransform()
	{
		return _object.GetTransform();
	}

	public Godot.Transform2D GetGlobalTransform()
	{
		return _object.GetGlobalTransform();
	}

	public Godot.Transform2D GetGlobalTransformWithCanvas()
	{
		return _object.GetGlobalTransformWithCanvas();
	}

	public Godot.Transform2D GetViewportTransform()
	{
		return _object.GetViewportTransform();
	}

	public Godot.Rect2 GetViewportRect()
	{
		return _object.GetViewportRect();
	}

	public Godot.Transform2D GetCanvasTransform()
	{
		return _object.GetCanvasTransform();
	}

	public Godot.Transform2D GetScreenTransform()
	{
		return _object.GetScreenTransform();
	}

	public Godot.Vector2 GetLocalMousePosition()
	{
		return _object.GetLocalMousePosition();
	}

	public Godot.Vector2 GetGlobalMousePosition()
	{
		return _object.GetGlobalMousePosition();
	}

	public Godot.Rid GetCanvas()
	{
		return _object.GetCanvas();
	}

	public CanvasLayer GetCanvasLayerNode()
	{
		return _object.GetCanvasLayerNode();
	}

	public World2D GetWorld2d()
	{
		return _object.GetWorld2D();
	}

	public void SetMaterial(Material @material)
	{
		_object.SetMaterial(@material);
	}

	public Material GetMaterial()
	{
		return _object.GetMaterial();
	}

	public void SetInstanceShaderParameter(Godot.StringName @name, Variant @value)
	{
		_object.SetInstanceShaderParameter(@name, @value);
	}

	public Variant GetInstanceShaderParameter(Godot.StringName @name)
	{
		return _object.GetInstanceShaderParameter(@name);
	}

	public void SetUseParentMaterial(bool @enable)
	{
		_object.SetUseParentMaterial(@enable);
	}

	public bool GetUseParentMaterial()
	{
		return _object.GetUseParentMaterial();
	}

	public void SetNotifyLocalTransform(bool @enable)
	{
		_object.SetNotifyLocalTransform(@enable);
	}

	public bool IsLocalTransformNotificationEnabled()
	{
		return _object.IsLocalTransformNotificationEnabled();
	}

	public void SetNotifyTransform(bool @enable)
	{
		_object.SetNotifyTransform(@enable);
	}

	public bool IsTransformNotificationEnabled()
	{
		return _object.IsTransformNotificationEnabled();
	}

	public void ForceUpdateTransform()
	{
		_object.ForceUpdateTransform();
	}

	public Godot.Vector2 MakeCanvasPositionLocal(Godot.Vector2 @viewport_point)
	{
		return _object.MakeCanvasPositionLocal(@viewport_point);
	}

	public InputEvent MakeInputLocal(InputEvent @event)
	{
		return _object.MakeInputLocal(@event);
	}

	public void SetVisibilityLayer(int @layer)
	{
		_object.SetVisibilityLayer((uint)@layer);
	}

	public int GetVisibilityLayer()
	{
		return (int)_object.GetVisibilityLayer();
	}

	public void SetVisibilityLayerBit(int @layer, bool @enabled)
	{
		_object.SetVisibilityLayerBit((uint)@layer, @enabled);
	}

	public bool GetVisibilityLayerBit(int @layer)
	{
		return _object.GetVisibilityLayerBit((uint)@layer);
	}

	public void SetTextureFilter(CanvasItem.TextureFilterEnum @mode)
	{
		_object.SetTextureFilter(@mode);
	}

	public CanvasItem.TextureFilterEnum GetTextureFilter()
	{
		return _object.GetTextureFilter();
	}

	public void SetTextureRepeat(CanvasItem.TextureRepeatEnum @mode)
	{
		_object.SetTextureRepeat(@mode);
	}

	public CanvasItem.TextureRepeatEnum GetTextureRepeat()
	{
		return _object.GetTextureRepeat();
	}

	public void SetClipChildrenMode(CanvasItem.ClipChildrenMode @mode)
	{
		_object.SetClipChildrenMode(@mode);
	}

	public CanvasItem.ClipChildrenMode GetClipChildrenMode()
	{
		return _object.GetClipChildrenMode();
	}

	public static void PrintOrphanNodes()
	{
		Node.PrintOrphanNodes();
	}

	public void AddSibling(Node @sibling, bool @force_readable_name = false)
	{
		_object.AddSibling(@sibling, @force_readable_name);
	}

	public void SetName(string @name)
	{
		_object.SetName(@name);
	}

	public Godot.StringName GetName()
	{
		return _object.GetName();
	}

	public void AddChild(Node @node, bool @force_readable_name = false, Node.InternalMode @internal = (Node.InternalMode)0)
	{
		_object.AddChild(@node, @force_readable_name, @internal);
	}

	public void RemoveChild(Node @node)
	{
		_object.RemoveChild(@node);
	}

	public void Reparent(Node @new_parent, bool @keep_global_transform = true)
	{
		_object.Reparent(@new_parent, @keep_global_transform);
	}

	public int GetChildCount(bool @include_internal = false)
	{
		return _object.GetChildCount(@include_internal);
	}

	public Godot.Collections.Array<Godot.Node> GetChildren(bool @include_internal = false)
	{
		return _object.GetChildren(@include_internal);
	}

	public Node GetChild(int @idx, bool @include_internal = false)
	{
		return _object.GetChild(@idx, @include_internal);
	}

	public bool HasNode(Godot.NodePath @path)
	{
		return _object.HasNode(@path);
	}

	public Node GetNode(Godot.NodePath @path)
	{
		return _object.GetNode(@path);
	}

	public Node GetNodeOrNull(Godot.NodePath @path)
	{
		return _object.GetNodeOrNull(@path);
	}

	public Node GetParent()
	{
		return _object.GetParent();
	}

	public Node FindChild(string @pattern, bool @recursive = true, bool @owned = true)
	{
		return _object.FindChild(@pattern, @recursive, @owned);
	}

	public Godot.Collections.Array<Godot.Node> FindChildren(string @pattern, string @type = "", bool @recursive = true, bool @owned = true)
	{
		return _object.FindChildren(@pattern, @type, @recursive, @owned);
	}

	public Node FindParent(string @pattern)
	{
		return _object.FindParent(@pattern);
	}

	public bool HasNodeAndResource(Godot.NodePath @path)
	{
		return _object.HasNodeAndResource(@path);
	}

	public Godot.Collections.Array GetNodeAndResource(Godot.NodePath @path)
	{
		return _object.GetNodeAndResource(@path);
	}

	public bool IsInsideTree()
	{
		return _object.IsInsideTree();
	}

	public bool IsPartOfEditedScene()
	{
		return _object.IsPartOfEditedScene();
	}

	public bool IsAncestorOf(Node @node)
	{
		return _object.IsAncestorOf(@node);
	}

	public bool IsGreaterThan(Node @node)
	{
		return _object.IsGreaterThan(@node);
	}

	public Godot.NodePath GetPath()
	{
		return _object.GetPath();
	}

	public Godot.NodePath GetPathTo(Node @node, bool @use_unique_path = false)
	{
		return _object.GetPathTo(@node, @use_unique_path);
	}

	public void AddToGroup(Godot.StringName @group, bool @persistent = false)
	{
		_object.AddToGroup(@group, @persistent);
	}

	public void RemoveFromGroup(Godot.StringName @group)
	{
		_object.RemoveFromGroup(@group);
	}

	public bool IsInGroup(Godot.StringName @group)
	{
		return _object.IsInGroup(@group);
	}

	public void MoveChild(Node @child_node, int @to_index)
	{
		_object.MoveChild(@child_node, @to_index);
	}

	public Godot.Collections.Array<StringName> GetGroups()
	{
		return _object.GetGroups();
	}

	public void SetOwner(Node @owner)
	{
		_object.SetOwner(@owner);
	}

	public Node GetOwner()
	{
		return _object.GetOwner();
	}

	public int GetIndex(bool @include_internal = false)
	{
		return _object.GetIndex(@include_internal);
	}

	public void PrintTree()
	{
		_object.PrintTree();
	}

	public void PrintTreePretty()
	{
		_object.PrintTreePretty();
	}

	public string GetTreeString()
	{
		return _object.GetTreeString();
	}

	public string GetTreeStringPretty()
	{
		return _object.GetTreeStringPretty();
	}

	public void SetSceneFilePath(string @scene_file_path)
	{
		_object.SetSceneFilePath(@scene_file_path);
	}

	public string GetSceneFilePath()
	{
		return _object.GetSceneFilePath();
	}

	public void PropagateNotification(int @what)
	{
		_object.PropagateNotification(@what);
	}

	public void PropagateCall(Godot.StringName @method, Godot.Collections.Array @args = null, bool @parent_first = false)
	{
		@args ??= new();
		_object.PropagateCall(@method, @args, @parent_first);
	}

	public void SetPhysicsProcess(bool @enable)
	{
		_object.SetPhysicsProcess(@enable);
	}

	public float GetPhysicsProcessDeltaTime()
	{
		return (float)_object.GetPhysicsProcessDeltaTime();
	}

	public bool IsPhysicsProcessing()
	{
		return _object.IsPhysicsProcessing();
	}

	public float GetProcessDeltaTime()
	{
		return (float)_object.GetProcessDeltaTime();
	}

	public void SetProcess(bool @enable)
	{
		_object.SetProcess(@enable);
	}

	public void SetProcessPriority(int @priority)
	{
		_object.SetProcessPriority(@priority);
	}

	public int GetProcessPriority()
	{
		return _object.GetProcessPriority();
	}

	public void SetPhysicsProcessPriority(int @priority)
	{
		_object.SetPhysicsProcessPriority(@priority);
	}

	public int GetPhysicsProcessPriority()
	{
		return _object.GetPhysicsProcessPriority();
	}

	public bool IsProcessing()
	{
		return _object.IsProcessing();
	}

	public void SetProcessInput(bool @enable)
	{
		_object.SetProcessInput(@enable);
	}

	public bool IsProcessingInput()
	{
		return _object.IsProcessingInput();
	}

	public void SetProcessShortcutInput(bool @enable)
	{
		_object.SetProcessShortcutInput(@enable);
	}

	public bool IsProcessingShortcutInput()
	{
		return _object.IsProcessingShortcutInput();
	}

	public void SetProcessUnhandledInput(bool @enable)
	{
		_object.SetProcessUnhandledInput(@enable);
	}

	public bool IsProcessingUnhandledInput()
	{
		return _object.IsProcessingUnhandledInput();
	}

	public void SetProcessUnhandledKeyInput(bool @enable)
	{
		_object.SetProcessUnhandledKeyInput(@enable);
	}

	public bool IsProcessingUnhandledKeyInput()
	{
		return _object.IsProcessingUnhandledKeyInput();
	}

	public void SetProcessMode(Node.ProcessModeEnum @mode)
	{
		_object.SetProcessMode(@mode);
	}

	public Node.ProcessModeEnum GetProcessMode()
	{
		return _object.GetProcessMode();
	}

	public bool CanProcess()
	{
		return _object.CanProcess();
	}

	public void SetProcessThreadGroup(Node.ProcessThreadGroupEnum @mode)
	{
		_object.SetProcessThreadGroup(@mode);
	}

	public Node.ProcessThreadGroupEnum GetProcessThreadGroup()
	{
		return _object.GetProcessThreadGroup();
	}

	public void SetProcessThreadMessages(Node.ProcessThreadMessagesEnum @flags)
	{
		_object.SetProcessThreadMessages(@flags);
	}

	public Node.ProcessThreadMessagesEnum GetProcessThreadMessages()
	{
		return _object.GetProcessThreadMessages();
	}

	public void SetProcessThreadGroupOrder(int @order)
	{
		_object.SetProcessThreadGroupOrder(@order);
	}

	public int GetProcessThreadGroupOrder()
	{
		return _object.GetProcessThreadGroupOrder();
	}

	public void SetDisplayFolded(bool @fold)
	{
		_object.SetDisplayFolded(@fold);
	}

	public bool IsDisplayedFolded()
	{
		return _object.IsDisplayedFolded();
	}

	public void SetProcessInternal(bool @enable)
	{
		_object.SetProcessInternal(@enable);
	}

	public bool IsProcessingInternal()
	{
		return _object.IsProcessingInternal();
	}

	public void SetPhysicsProcessInternal(bool @enable)
	{
		_object.SetPhysicsProcessInternal(@enable);
	}

	public bool IsPhysicsProcessingInternal()
	{
		return _object.IsPhysicsProcessingInternal();
	}

	public void SetPhysicsInterpolationMode(Node.PhysicsInterpolationModeEnum @mode)
	{
		_object.SetPhysicsInterpolationMode(@mode);
	}

	public Node.PhysicsInterpolationModeEnum GetPhysicsInterpolationMode()
	{
		return _object.GetPhysicsInterpolationMode();
	}

	public bool IsPhysicsInterpolated()
	{
		return _object.IsPhysicsInterpolated();
	}

	public bool IsPhysicsInterpolatedAndEnabled()
	{
		return _object.IsPhysicsInterpolatedAndEnabled();
	}

	public void ResetPhysicsInterpolation()
	{
		_object.ResetPhysicsInterpolation();
	}

	public void SetAutoTranslateMode(Node.AutoTranslateModeEnum @mode)
	{
		_object.SetAutoTranslateMode(@mode);
	}

	public Node.AutoTranslateModeEnum GetAutoTranslateMode()
	{
		return _object.GetAutoTranslateMode();
	}

	public void SetTranslationDomainInherited()
	{
		_object.SetTranslationDomainInherited();
	}

	public Window GetWindow()
	{
		return _object.GetWindow();
	}

	public Window GetLastExclusiveWindow()
	{
		return _object.GetLastExclusiveWindow();
	}

	public SceneTree GetTree()
	{
		return _object.GetTree();
	}

	public Tween CreateTween()
	{
		return _object.CreateTween();
	}

	public Node Duplicate(int @flags = 15)
	{
		return _object.Duplicate(@flags);
	}

	public void ReplaceBy(Node @node, bool @keep_groups = false)
	{
		_object.ReplaceBy(@node, @keep_groups);
	}

	public void SetSceneInstanceLoadPlaceholder(bool @load_placeholder)
	{
		_object.SetSceneInstanceLoadPlaceholder(@load_placeholder);
	}

	public bool GetSceneInstanceLoadPlaceholder()
	{
		return _object.GetSceneInstanceLoadPlaceholder();
	}

	public void SetEditableInstance(Node @node, bool @is_editable)
	{
		_object.SetEditableInstance(@node, @is_editable);
	}

	public bool IsEditableInstance(Node @node)
	{
		return _object.IsEditableInstance(@node);
	}

	public Viewport GetViewport()
	{
		return _object.GetViewport();
	}

	public void QueueFree()
	{
		_object.QueueFree();
	}

	public void RequestReady()
	{
		_object.RequestReady();
	}

	public bool IsNodeReady()
	{
		return _object.IsNodeReady();
	}

	public void SetMultiplayerAuthority(int @id, bool @recursive = true)
	{
		_object.SetMultiplayerAuthority(@id, @recursive);
	}

	public int GetMultiplayerAuthority()
	{
		return _object.GetMultiplayerAuthority();
	}

	public bool IsMultiplayerAuthority()
	{
		return _object.IsMultiplayerAuthority();
	}

	public MultiplayerApi GetMultiplayer()
	{
		return _object.GetMultiplayer();
	}

	public void RpcConfig(Godot.StringName @method, Variant @config)
	{
		_object.RpcConfig(@method, @config);
	}

	public Variant GetRpcConfig()
	{
		return _object.GetRpcConfig();
	}

	public void SetEditorDescription(string @editor_description)
	{
		_object.SetEditorDescription(@editor_description);
	}

	public string GetEditorDescription()
	{
		return _object.GetEditorDescription();
	}

	public void SetUniqueNameInOwner(bool @enable)
	{
		_object.SetUniqueNameInOwner(@enable);
	}

	public bool IsUniqueNameInOwner()
	{
		return _object.IsUniqueNameInOwner();
	}

	public string Atr(string @message, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.Atr(@message, @context);
	}

	public string AtrN(string @message, Godot.StringName @plural_message, int @n, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.AtrN(@message, @plural_message, @n, @context);
	}

	public Godot.Error Rpc(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.Rpc(@method, varargs);
	}

	public Godot.Error RpcId(int @peer_id, Godot.StringName @method, params Variant[] varargs)
	{
		return _object.RpcId(@peer_id, @method, varargs);
	}

	public void UpdateConfigurationWarnings()
	{
		_object.UpdateConfigurationWarnings();
	}

	public Variant CallDeferredThreadGroup(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallDeferredThreadGroup(@method, varargs);
	}

	public void SetDeferredThreadGroup(Godot.StringName @property, Variant @value)
	{
		_object.SetDeferredThreadGroup(@property, @value);
	}

	public void NotifyDeferredThreadGroup(int @what)
	{
		_object.NotifyDeferredThreadGroup(@what);
	}

	public Variant CallThreadSafe(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallThreadSafe(@method, varargs);
	}

	public void SetThreadSafe(Godot.StringName @property, Variant @value)
	{
		_object.SetThreadSafe(@property, @value);
	}

	public void NotifyThreadSafe(int @what)
	{
		_object.NotifyThreadSafe(@what);
	}

	public void Free()
	{
		_object.Free();
	}

	public string GetClass()
	{
		return _object.GetClass();
	}

	public bool IsClass(string @class)
	{
		return _object.IsClass(@class);
	}

	public void Set(Godot.StringName @property, Variant @value)
	{
		_object.Set(@property, @value);
	}

	public Variant Get(Godot.StringName @property)
	{
		return _object.Get(@property);
	}

	public void SetIndexed(Godot.NodePath @property_path, Variant @value)
	{
		_object.SetIndexed(@property_path, @value);
	}

	public Variant GetIndexed(Godot.NodePath @property_path)
	{
		return _object.GetIndexed(@property_path);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetPropertyList()
	{
		return _object.GetPropertyList();
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetMethodList()
	{
		return _object.GetMethodList();
	}

	public bool PropertyCanRevert(Godot.StringName @property)
	{
		return _object.PropertyCanRevert(@property);
	}

	public Variant PropertyGetRevert(Godot.StringName @property)
	{
		return _object.PropertyGetRevert(@property);
	}

	public void Notification(int @what, bool @reversed = false)
	{
		_object.Notification(@what, @reversed);
	}

	public override string ToString()
	{
		return _object.ToString();
	}

	public ulong GetInstanceId()
	{
		return _object.GetInstanceId();
	}

	public void SetScript(Variant @script)
	{
		_object.SetScript(@script);
	}

	public Variant GetScript()
	{
		return _object.GetScript();
	}

	public void SetMeta(Godot.StringName @name, Variant @value)
	{
		_object.SetMeta(@name, @value);
	}

	public void RemoveMeta(Godot.StringName @name)
	{
		_object.RemoveMeta(@name);
	}

	public Variant GetMeta(Godot.StringName @name, Variant @default = default)
	{
		return _object.GetMeta(@name, @default);
	}

	public bool HasMeta(Godot.StringName @name)
	{
		return _object.HasMeta(@name);
	}

	public Godot.Collections.Array<StringName> GetMetaList()
	{
		return _object.GetMetaList();
	}

	public void AddUserSignal(string @signal, Godot.Collections.Array @arguments = null)
	{
		@arguments ??= new();
		_object.AddUserSignal(@signal, @arguments);
	}

	public bool HasUserSignal(Godot.StringName @signal)
	{
		return _object.HasUserSignal(@signal);
	}

	public void RemoveUserSignal(Godot.StringName @signal)
	{
		_object.RemoveUserSignal(@signal);
	}

	public Godot.Error EmitSignal(Godot.StringName @signal, params Variant[] varargs)
	{
		return _object.EmitSignal(@signal, varargs);
	}

	public Variant Call(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.Call(@method, varargs);
	}

	public Variant CallDeferred(Godot.StringName @method, params Variant[] varargs)
	{
		return _object.CallDeferred(@method, varargs);
	}

	public void SetDeferred(Godot.StringName @property, Variant @value)
	{
		_object.SetDeferred(@property, @value);
	}

	public Variant Callv(Godot.StringName @method, Godot.Collections.Array @arg_array)
	{
		return _object.Callv(@method, @arg_array);
	}

	public bool HasMethod(Godot.StringName @method)
	{
		return _object.HasMethod(@method);
	}

	public int GetMethodArgumentCount(Godot.StringName @method)
	{
		return _object.GetMethodArgumentCount(@method);
	}

	public bool HasSignal(Godot.StringName @signal)
	{
		return _object.HasSignal(@signal);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetSignalList()
	{
		return _object.GetSignalList();
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetSignalConnectionList(Godot.StringName @signal)
	{
		return _object.GetSignalConnectionList(@signal);
	}

	public Godot.Collections.Array<Godot.Collections.Dictionary> GetIncomingConnections()
	{
		return _object.GetIncomingConnections();
	}

	public Godot.Error Connect(Godot.StringName @signal, Godot.Callable @callable, uint @flags = (uint)0)
	{
		return _object.Connect(@signal, @callable, @flags);
	}

	public void Disconnect(Godot.StringName @signal, Godot.Callable @callable)
	{
		_object.Disconnect(@signal, @callable);
	}

	public bool IsConnected(Godot.StringName @signal, Godot.Callable @callable)
	{
		return _object.IsConnected(@signal, @callable);
	}

	public bool HasConnections(Godot.StringName @signal)
	{
		return _object.HasConnections(@signal);
	}

	public void SetBlockSignals(bool @enable)
	{
		_object.SetBlockSignals(@enable);
	}

	public bool IsBlockingSignals()
	{
		return _object.IsBlockingSignals();
	}

	public void NotifyPropertyListChanged()
	{
		_object.NotifyPropertyListChanged();
	}

	public void SetMessageTranslation(bool @enable)
	{
		_object.SetMessageTranslation(@enable);
	}

	public bool CanTranslateMessages()
	{
		return _object.CanTranslateMessages();
	}

	public string Tr(Godot.StringName @message, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.Tr(@message, @context);
	}

	public string TrN(Godot.StringName @message, Godot.StringName @plural_message, int @n, Godot.StringName @context = null)
	{
		@context ??= "";
		return _object.TrN(@message, @plural_message, @n, @context);
	}

	public Godot.StringName GetTranslationDomain()
	{
		return _object.GetTranslationDomain();
	}

	public void SetTranslationDomain(Godot.StringName @domain)
	{
		_object.SetTranslationDomain(@domain);
	}

	public bool IsQueuedForDeletion()
	{
		return _object.IsQueuedForDeletion();
	}

	public void CancelFree()
	{
		_object.CancelFree();
	}

	#endregion

	#region Signals

	public event Action<byte[]> DataSent
	{
		add
		{
			Connect(SignalName.DataSent, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.DataSent, Callable.From(value));
		}
	}

	public event Action<byte[], GodotObject> KeyPressed
	{
		add
		{
			Connect(SignalName.KeyPressed, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.KeyPressed, Callable.From(value));
		}
	}

	public event Action<Godot.Vector2I> SizeChanged
	{
		add
		{
			Connect(SignalName.SizeChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.SizeChanged, Callable.From(value));
		}
	}

	public event Action Bell
	{
		add
		{
			Connect(SignalName.Bell, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Bell, Callable.From(value));
		}
	}

	#endregion

	#region Inherited Signals

	public event Action Resized
	{
		add
		{
			Connect(SignalName.Resized, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Resized, Callable.From(value));
		}
	}

	public event Action<InputEvent> GuiInput
	{
		add
		{
			Connect(SignalName.GuiInput, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.GuiInput, Callable.From(value));
		}
	}

	public event Action MouseEntered
	{
		add
		{
			Connect(SignalName.MouseEntered, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.MouseEntered, Callable.From(value));
		}
	}

	public event Action MouseExited
	{
		add
		{
			Connect(SignalName.MouseExited, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.MouseExited, Callable.From(value));
		}
	}

	public event Action FocusEntered
	{
		add
		{
			Connect(SignalName.FocusEntered, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.FocusEntered, Callable.From(value));
		}
	}

	public event Action FocusExited
	{
		add
		{
			Connect(SignalName.FocusExited, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.FocusExited, Callable.From(value));
		}
	}

	public event Action SizeFlagsChanged
	{
		add
		{
			Connect(SignalName.SizeFlagsChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.SizeFlagsChanged, Callable.From(value));
		}
	}

	public event Action MinimumSizeChanged
	{
		add
		{
			Connect(SignalName.MinimumSizeChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.MinimumSizeChanged, Callable.From(value));
		}
	}

	public event Action ThemeChanged
	{
		add
		{
			Connect(SignalName.ThemeChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ThemeChanged, Callable.From(value));
		}
	}

	public event Action Draw
	{
		add
		{
			Connect(SignalName.Draw, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Draw, Callable.From(value));
		}
	}

	public event Action VisibilityChanged
	{
		add
		{
			Connect(SignalName.VisibilityChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.VisibilityChanged, Callable.From(value));
		}
	}

	public event Action Hidden
	{
		add
		{
			Connect(SignalName.Hidden, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Hidden, Callable.From(value));
		}
	}

	public event Action ItemRectChanged
	{
		add
		{
			Connect(SignalName.ItemRectChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ItemRectChanged, Callable.From(value));
		}
	}

	public event Action Ready
	{
		add
		{
			Connect(SignalName.Ready, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Ready, Callable.From(value));
		}
	}

	public event Action Renamed
	{
		add
		{
			Connect(SignalName.Renamed, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.Renamed, Callable.From(value));
		}
	}

	public event Action TreeEntered
	{
		add
		{
			Connect(SignalName.TreeEntered, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeEntered, Callable.From(value));
		}
	}

	public event Action TreeExiting
	{
		add
		{
			Connect(SignalName.TreeExiting, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeExiting, Callable.From(value));
		}
	}

	public event Action TreeExited
	{
		add
		{
			Connect(SignalName.TreeExited, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.TreeExited, Callable.From(value));
		}
	}

	public event Action<Node> ChildEnteredTree
	{
		add
		{
			Connect(SignalName.ChildEnteredTree, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildEnteredTree, Callable.From(value));
		}
	}

	public event Action<Node> ChildExitingTree
	{
		add
		{
			Connect(SignalName.ChildExitingTree, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildExitingTree, Callable.From(value));
		}
	}

	public event Action ChildOrderChanged
	{
		add
		{
			Connect(SignalName.ChildOrderChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ChildOrderChanged, Callable.From(value));
		}
	}

	public event Action<Node> ReplacingBy
	{
		add
		{
			Connect(SignalName.ReplacingBy, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ReplacingBy, Callable.From(value));
		}
	}

	public event Action<Node> EditorDescriptionChanged
	{
		add
		{
			Connect(SignalName.EditorDescriptionChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.EditorDescriptionChanged, Callable.From(value));
		}
	}

	public event Action EditorStateChanged
	{
		add
		{
			Connect(SignalName.EditorStateChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.EditorStateChanged, Callable.From(value));
		}
	}

	public event Action ScriptChanged
	{
		add
		{
			Connect(SignalName.ScriptChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.ScriptChanged, Callable.From(value));
		}
	}

	public event Action PropertyListChanged
	{
		add
		{
			Connect(SignalName.PropertyListChanged, Callable.From(value));
		}
		remove
		{
			Disconnect(SignalName.PropertyListChanged, Callable.From(value));
		}
	}

	#endregion
}
